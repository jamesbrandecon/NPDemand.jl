var documenterSearchIndex = {"docs":
[{"location":"functions/#Function-documentation","page":"Function Documentation","title":"Function documentation","text":"","category":"section"},{"location":"functions/","page":"Function Documentation","title":"Function Documentation","text":"define_problem","category":"page"},{"location":"functions/#NPDemand.define_problem","page":"Function Documentation","title":"NPDemand.define_problem","text":"define_problem(df::DataFrame; exchange = [], index_vars = [\"prices\"], FE = [], constraints = [], bO = 2, tol = 1e-5)\n\nConstructs a problem::NPDProblem using the provided problem characteristics. Inputs: \n\nexchange: A vector of groups of products which are exchangeable. E.g., with 4 goods, if the first\n\nand second are exchangeable and so are the third and fourth, set exchange = [[1 2], [3 4]].\n\nindex_vars: String array listing column names in df which represent variables that enter the inverted index.\n\"prices\" must be the first element of index_vars\nFE: String array listing column names in df which should be included as fixed effects.\nNote: All fixed effects are estimated as parameters by the minimizer, so be careful adding fixed effects for variables that take many values.\nbO: Order of the univariate Bernstein polynomials in market shares. Default is 2.\nconstraint_tol: Tolerance specifying tightness of constraints\nobj_xtol: Tolerance specifying x_tol in Optim.Options()\nobj_ftol: Tolerance specifying f_tol in Optim.Options()\nchunk_size: Controls chunk size in ForwardDiff.Gradient autodiff calculation for nonlinear constraints. Only used if :subs_in_group specified. \nconstraints: A list of symbols of accepted constraints. Currently supported constraints are: \n:monotone  \n:all_substitutes \n:diagonal_dominance_group \n:diagonal_dominance_all \n:subs_in_group (Note: this constraint is the only available nonlinear constraint and will slow down estimation considerably)\nverbose: if false, will not print updates as problem is generated\n\n\n\n\n\n","category":"function"},{"location":"functions/","page":"Function Documentation","title":"Function Documentation","text":"update_constraints!","category":"page"},{"location":"functions/#NPDemand.update_constraints!","page":"Function Documentation","title":"NPDemand.update_constraints!","text":"update_constraints!(problem::NPDProblem, new_constraints::Vector{Symbol})\n\nRe-calculates constraint matrices under new_constraints, ignoring previous constraints used to define the problem. The exchangeability constraint is an exception. To change anything about the structure of exchangeability for the problem changes, define a new problem.\n\n\n\n\n\n","category":"function"},{"location":"functions/","page":"Function Documentation","title":"Function Documentation","text":"estimate!","category":"page"},{"location":"functions/#NPDemand.estimate!","page":"Function Documentation","title":"NPDemand.estimate!","text":"estimate!(problem::NPDProblem; max_iterations = 10000, show_trace = false, chunk_size = Int[])\n\nestimate! solves problem subject to provided constraints, and replaces problem.results with the resulting parameter vector. To enforce constraints, we iteratively minimize the sum of the objective function and a penalty term capturing violations of the constraint.  For each outer iteration, we increase the size of the penalty term by an order of magnitude.  \n\nOptions: \n\nmax_inner_iterations: controls the number of inner iterations for each call to the optimizer via Optim.jl\nmax_outer_iterations: controls the number of total calls to Optim, i.e., the number of times the penalty enforcing the constraints will increase before exiting\nshow_trace: if true, Optim will print the trace for each outer iteration. \nverbose: if false, will not print outer iteration updates within optimization\n\n\n\n\n\n","category":"function"},{"location":"functions/","page":"Function Documentation","title":"Function Documentation","text":"price_elasticities!","category":"page"},{"location":"functions/#NPDemand.price_elasticities!","page":"Function Documentation","title":"NPDemand.price_elasticities!","text":"price_elasticities!(problem::NPDProblem)\n\nTakes the solved problem as first argument, a DataFrame as the second argument, and evaluates all price elasticities in-sample.  Currently does not calculate out-of-sample price elasticities. For this, use the function compute_demand_function!. \n\nResults of this function are stored as a DataFrame in problem.allelasticities. Results can be summarized by hand or using the `summarizeelasticities` function.  We also store the Jacobian of the demand function with respect to prices, which can be used to calculate other quantities of interest.\n\n\n\n\n\n","category":"function"},{"location":"functions/","page":"Function Documentation","title":"Function Documentation","text":"compute_demand_function!","category":"page"},{"location":"functions/#NPDemand.compute_demand_function!","page":"Function Documentation","title":"NPDemand.compute_demand_function!","text":"compute_demand_function!(problem, df; max_iter = 1000, show_trace = false)\n\ncompute_demand_function! estimates the demand function/curve using NPD estimates calculated via estimate!.\n\nThe function takes in an estimated problem::NPDProblem and a dataframe with counterfactual values of the  covariates in the utility function. One must specify all fields that were used in estimation (including shares). The function will change the values of df[!,r\"shares\"] to take on the value of the estimated demand function.\n\nOptions: \n\nmax_iter: controls the number of iterations for the nonlinear solver calculating market shares. Default is 1000 but well-estimated problems should converge faster.\nshow_trace: if true, Optim will print the trace for each iteration of the nonlinear solver. \ncompute_own_elasticities: NOT yet implementedâ€“ if true, will also generate columns called own_elast which will include estimated own-price elasticities at all counterfactual points.\n\n\n\n\n\n","category":"function"},{"location":"details/#Implementation-Details","page":"Implementation Details","title":"Implementation Details","text":"","category":"section"},{"location":"details/","page":"Implementation Details","title":"Implementation Details","text":"This page explains both the underlying economic model that our package assumes and some of the details concerning our approach, which implements a nonparametric estimator as in Compiani, 2022 with a more general suite of (linear and nonlinear) constraints and implementation/estimation options. ","category":"page"},{"location":"details/#The-Nonparametric-Demand-Estimation-Problem","page":"Implementation Details","title":"The Nonparametric Demand Estimation Problem","text":"","category":"section"},{"location":"details/","page":"Implementation Details","title":"Implementation Details","text":"Our package estimates a demand function for J goods, allowing flexible substitution patterns including some forms of complementarities. Letting s denote market shares, the assumed demand function takes the following form: ","category":"page"},{"location":"details/","page":"Implementation Details","title":"Implementation Details","text":"    s_jt = sigma_j(delta_jt)","category":"page"},{"location":"details/","page":"Implementation Details","title":"Implementation Details","text":"where jt index products and markets respectively. Note that sigma is indexed by j, allowing the demand functions of different goods to take different forms. The arguments of sigma are delta, which we assume takes the following form: ","category":"page"},{"location":"details/","page":"Implementation Details","title":"Implementation Details","text":"    delta_jt = beta x_jt + xi_jt","category":"page"},{"location":"details/","page":"Implementation Details","title":"Implementation Details","text":"where x_jt denote observable product characteristics including price, and xi_jt denotes unobservable demand shifters at the product-market level. Direct estimation of sigma would be complicated here due to the fact that xi enters sigma nonlinearly. Instead, under conditions stated in Compiani, 2022, we can invert sigma and estiamte the resulting inverse. The inverse demand equation is then: ","category":"page"},{"location":"details/","page":"Implementation Details","title":"Implementation Details","text":"    x_jt = sigma^-1_j(s_jt) - xi_jt","category":"page"},{"location":"details/","page":"Implementation Details","title":"Implementation Details","text":"The inverse demand functions can then be estimated via Nonparametric Instrumental Variables (NPIV). We discuss the exact implementation below. ","category":"page"},{"location":"details/#Estimation","page":"Implementation Details","title":"Estimation","text":"","category":"section"},{"location":"details/","page":"Implementation Details","title":"Implementation Details","text":"The estimation problem takes the following form: ","category":"page"},{"location":"details/","page":"Implementation Details","title":"Implementation Details","text":"    min_theta sum_j=1^J Big sum_t=1^T tilde xi_jt Big (A_jA_j)^- Big sum_t=1^T tilde xi_jt Big ","category":"page"},{"location":"details/","page":"Implementation Details","title":"Implementation Details","text":"where tilde xi_jt are the values of xi_jt implies by the current estimate of the demand system. The matrix A_j is a matrix of demand instruments for product j.","category":"page"},{"location":"details/","page":"Implementation Details","title":"Implementation Details","text":"In practice, we found this problem to be difficult to efficiently solve as written. Instead, during the process of problem construction, we reformulate the problem by multiplying out the product of matrices above. In particular, for appropriately defined values of yX and Z, we can rewrite the objective function as ","category":"page"},{"location":"details/","page":"Implementation Details","title":"Implementation Details","text":"    min_theta (y - Xtheta) Z (y - X theta)","category":"page"},{"location":"details/","page":"Implementation Details","title":"Implementation Details","text":"For complicated problems, theta can include hundreds of parameters, meaning that Z and X may have hundreds of columns (and, in the case of Z, rows). Manipulating  these large matrices directly resulted in an estimation process that was quite slow even with analytic gradients. However, note that if we multiply out the product above, we get ","category":"page"},{"location":"details/","page":"Implementation Details","title":"Implementation Details","text":"    yZy + yZ Xtheta - thetaXZy + thetaXX theta ","category":"page"},{"location":"details/","page":"Implementation Details","title":"Implementation Details","text":"Note, then, that the first term is constant with respect to theta, and the rest of the terms are relatively small matrices which can be pre-computed prior to estimation.  In practice, to handle normalizations and to treat the components theta that correspond to the index delta differently from those that correspond to the inverse demand functions themselves,  we use a slightly different formulation, but the impact is the same. By pre-computing these matrices and storing them during problem construction, we find that estimation is dramatically faster.  The only cost we pay is that this process introduces a small amount of (floating-point) errors in our objective function construction, but we find that these are negligible even in simulated data with unreasonably high signal to noise ratios (i.e., small optimized objective values). If users report that these errors appear non-negligible in practice, we may update the package with an option to solve the problem in the standard way. ","category":"page"},{"location":"details/","page":"Implementation Details","title":"Implementation Details","text":"Although in many cases the economic constraints of interest are linear, the package allows for nonlinear constraints as well. In order to incorporate both constraints, we  rely on a generic unconstrained optimizer (LBFGS in Optim.jl) to solve the problem, where constraints are imposed as a penalty term in the objective function. In any problem with  exchangeability imposed, we first solve the problem under exchangeability alone (no other constraints). We then use the solution to the unconstrained problem as a starting point, and re-solve  the problem with all constraints included in penalty terms. We solve this constrained problem repeatedly, increasing the magnitude of the penalty parameter each time, until either the constraints  are satisfied or the number of iterations surpasses the value of max_outer_iterations provided in the problem definition. ","category":"page"},{"location":"details/#Constraints","page":"Implementation Details","title":"Constraints","text":"","category":"section"},{"location":"details/","page":"Implementation Details","title":"Implementation Details","text":"One of the goals of our package was to build a structure that would allow for both linear and nonlinear constraints to be incorporated into nonparametric demand estimation. As a result, we do not rely on CVX (Convex.jl) or other linear solvers to solve our problem, even though with the appropriate constraints the problem we solve is well-behaved. Instead, for linear constraints, we solve the problem via LBFGS with analytic gradients (for both the objective function and gradients), and for nonlinear constraints we use Julia's autodiff capabilities ","category":"page"},{"location":"details/","page":"Implementation Details","title":"Implementation Details","text":"Solve the unconstrained problem  a. Note: the :exchangeability constraint is imposed in the construction of the NPDProblem, so the \"unconstrained\" step when :exchangeability is specified  \nRe-solve the problem with a penalty term which is quadratic in the distance to the constrained feasible space \nRepeat (2), increasing the magnitude of the penalty term, until the constraints are satisfied. ","category":"page"},{"location":"details/#Fixed-Effects","page":"Implementation Details","title":"Fixed Effects","text":"","category":"section"},{"location":"details/","page":"Implementation Details","title":"Implementation Details","text":"Fixed effects are estimated as parameters, not absorbed from the data. So, be careful including fixed effects with too many values, as this may both slow down the optimization and require more memory.","category":"page"},{"location":"details/","page":"Implementation Details","title":"Implementation Details","text":"To include fixed effects (categorical variables), use the option FE to provide a vector of strings, where each element of the vector is a name of a column in the provided data df. Note however that at present, variables that are included as fixed effect must be constant across products within a market. The only exception to this rule is \"product\" which is a keyword which will produce product fixed-effects. There need not be a column named product in the data, and in fact the code will ignore it if it's there. ","category":"page"},{"location":"details/","page":"Implementation Details","title":"Implementation Details","text":"warning: Warning\nGiven how commmon fixed effect regression packages have become, users may expect the package to smartly identify and drop singletons and perform colinearity checks. This it not yet implementedâ€“ at present, the only thing we do beyond including all fixed effects as dummy variables is to drop one level per dimension of fixed effects. ","category":"page"},{"location":"usage/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Having described the some of the estimation details, we now describe how to use the package.","category":"page"},{"location":"usage/#Defining-Problems","page":"Usage","title":"Defining Problems","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"The first step to estimating demand is to define the problem. The define_problem function takes the following arguments:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"df: a DataFrame containing the data to be used in estimation.\nexchange: a list of lists of integers, where each list of integers corresponds to a group of products that are exchangeable.\nindex_vars: a list of strings, where each string corresponds to a column in df that contains the index variables for the demand system. \nconstraints: a list of symbols, where each symbol corresponds to a constraint to be imposed on the demand system.\nbO: an integer indicating the order of Bernstein polynomials to be used in the demand system. The default value is 2, and larger values will result in (significantly) more parameters.\nFE: a list of strings, where each string corresponds to a column in df that contains fixed effects to be included in the demand system.\nconstraint_tol: the tolerance for the constraint satisfaction problem.\nobj_xtol: the tolerance for the unconstrained optimization problem.\nobj_ftol: the tolerance for the unconstrained optimization problem.","category":"page"},{"location":"usage/#Constraints","page":"Usage","title":"Constraints","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"So far, we have implemented the following constraints: ","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":":exchangeability: Products given by exchange are exchangeable, meaning that product identities do not affect demand. Product fixed effects can stil be estimated\n:monotone: All demand functions are monotonic in their own index \n:diagonal\\_dominance\\_all: All demand functions are diagonally dominant\n:diagonal\\_dominance\\_group: All demand functions are diagonally dominant within exchangeable groups\n:all_substitutes: All inverse demand functions are increasing in all indexes, which is a necessary condition for all products to be substitutes\n:subs\\_in\\_group: Cross-price elasticities of demand are positive for every pair of goods within an exchangeable group. No restrictions on the Jacobian are made across groups","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"All of these constraints are linear except for the last. ","category":"page"},{"location":"usage/#Example","page":"Usage","title":"Example","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Here is an example of a problem definition using many of the options described above: ","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"bO = 2; \nexchange = [[1 2], [3 4]]\nindex_vars = [\"prices\", \"x\"]\nconstraint_tol = 1e-10;\nobj_xtol = 1e-5;\nobj_ftol = 1e-5;\n\nconstraints = [:exchangeability, :diagonal_dominance_all, :monotone, :subs_in_group]; \nnpd_problem = define_problem(df;  \n                            exchange = exchange,\n                            index_vars = index_vars, \n                            constraints = constraints,\n                            bO = bO,\n                            FE = [],\n                            constraint_tol = constraint_tol,\n                            obj_xtol = obj_xtol, \n                            grid_size = 2,\n                            obj_ftol = obj_ftol); ","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"After running this command, npd_problem is now of type NPDemand.NPDProblem. The problem contains many components that would be difficult for users to read and understand,  so for ease of use we have included a show method for NPDemand.NPDProblem which prints out the core components of the problem definition. ","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"@show npd_problem;","category":"page"},{"location":"usage/#One-line-estimation:-estimate!","page":"Usage","title":"One-line estimation: estimate!","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Estimation of a defined problem can be done via a call to the NPDemand.estimate! function, as shown here: ","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"estimate!(npd_problem, max_outer_iterations = 10, show_trace = false, verbose = true)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The key options and inputs to this function are as follows:      - npd_problem: the problem to be estimated, of type NPDemand.NPDProblem.     - max_outer_iterations: the maximum number of iterations to be used in the outer loop (the loop over which the penalty which enforces constraints is increased) of the estimation procedure.      - max_inner_iterations: the maximum number of iterations to be used in the inner optimizer. This should be set to a large number.      - verbose: a boolean indicating whether to print the steps of estimation, including any pre-processing and the number of iterations of the outer loop. The default value is true.     - show_trace: a boolean indicating whether to print the trace of the inner loop of the estimation procedure. The default value is true.","category":"page"},{"location":"postestimation/#Post-Estimation","page":"Post-Estimation","title":"Post-Estimation","text":"","category":"section"},{"location":"postestimation/#Estimated-Price-Elasticities","page":"Post-Estimation","title":"Estimated Price Elasticities","text":"","category":"section"},{"location":"postestimation/","page":"Post-Estimation","title":"Post-Estimation","text":"The main output that can be calculated from the results of estimate! is the full set of price elasticities of demand. Calculating all price elasticities requires  a single call to the price_elasticities! function. After this call, you can access the full set of elasticities via the field npd_problem.all_elasticities, which is an Array of matrices.  Each element of the array is the matrix of price elasticities for a market, where the (ij) element of each matrix denotes the elasticity of demand for product i with respect to the price of product j. Alternatively, you can extract the own-price elasticities for each product using the own_elasticities function or summarize elasticities across markets using the summarize_elasticities function. Some example usage: ","category":"page"},{"location":"postestimation/","page":"Post-Estimation","title":"Post-Estimation","text":"price_elasticities!(npd_problem); # Calculate all elasticities \n\nown = own_elasticities(npd_problem) # Extract own-price elasticities \n\n# Summaries of elasticities\nsummarize_elasticities(npd_problem, \"median\")\nsummarize_elasticities(npd_problem, \"mean\")\nsummarize_elasticities(npd_problem, \"quantile\"; q = 0.3) # 30th percentile","category":"page"},{"location":"postestimation/#Estimated-Demand-Functions","page":"Post-Estimation","title":"Estimated Demand Functions","text":"","category":"section"},{"location":"postestimation/","page":"Post-Estimation","title":"Post-Estimation","text":"One of the benefits of nonparametric demand estimation is that it can allow us to study the shape of the demand function and compare it to the demand functions implied by alternative models. For this purpose, or for evaluating the impact of counterfactual prices, it may be useful to estimate the demand function for a given set of prices of one good while keeping prices of other goods fixed, or at a vector of alternative prices. ","category":"page"},{"location":"postestimation/","page":"Post-Estimation","title":"Post-Estimation","text":"This can be done using the compute_demand_function! function, which takes in a NPDProblem and a DataFrame which contains prices and market shares. The function then modifies the provided DataFrame, filling in the columns shares0, shares1, ..., sharesJ with the estimated shares for each market. This is a sightly more complicated task than in many structural models, because the parameters we are estimating govern the inverse demand system rather than the demand system itself. In order to calculate the (non-inverted) demand function, we have to perform a nonlinear search over market shares to match the user-provided prices and other index covariates. ","category":"page"},{"location":"postestimation/","page":"Post-Estimation","title":"Post-Estimation","text":"warning: Warning\ncompute_demand_function! can currently only calculate counterfacual market shares assuming that all demand shocks (xi) are set to zero.  ","category":"page"},{"location":"postestimation/","page":"Post-Estimation","title":"Post-Estimation","text":"Here is an example of how to use this function to compute the demand function, varying the price of product 1 while keeping prices of other goods fixed. ","category":"page"},{"location":"postestimation/","page":"Post-Estimation","title":"Post-Estimation","text":"# Create a new DataFrame which can be filled in with estimated demand functions\nalt_price_df = DataFrame(); # Initialize dataframe \nalt_price_df.prices1 = 1.1 .* ones(10); alt_price_df.prices2 .= 1.1; alt_price_df.prices3 .= 1.1;\nalt_price_df.prices0 .= collect(range(0.7,1.3, length=10));\nfor j = 0:3\n    alt_price_df[!,\"shares$j\"] .=0; # shares set to zero to initialize the fields-- compute_demand_function will ignore and replace these values\n    alt_price_df[!,\"x$j\"] .= 0.5; \nend\n\ncompute_demand_function!(npd_problem, alt_price_df; max_iter = 1000, show_trace = false);","category":"page"},{"location":"postestimation/","page":"Post-Estimation","title":"Post-Estimation","text":"As mentioned in the note above, if you run this code you will notice that the output above generates a warning that the function \"Assumes residual demand shifters set to zero.\" This refers to the values of the residuals xi. Other alternative values for xi will likely be implemented in future versions of the package. After running compute_demand_function!, we can then plot the estimated demand functions (stored in shares0...shares3). Here is some example code which plots all counterfactual shares: ","category":"page"},{"location":"postestimation/","page":"Post-Estimation","title":"Post-Estimation","text":"plot(p, alt_price_df.prices0, alt_price_df.shares0, \n    color = :red, \n    lw = 1.5, label = \"Est. Share 1\", \n    xlabel = \"Price 1\", \n    ylabel = \"Market Share\");\nplot!(alt_price_df.prices0, alt_price_df.shares1, color = :grey, label = \"Est. Share 2\");\nplot!(alt_price_df.prices0, alt_price_df.shares2, color = :grey, label = \"Est. Share 3\");\nplot!(alt_price_df.prices0, alt_price_df.shares3, color = :grey, label = \"Est. Share 4\");","category":"page"},{"location":"#NPDemand.jl","page":"NPDemand.jl","title":"NPDemand.jl","text":"","category":"section"},{"location":"","page":"NPDemand.jl","title":"NPDemand.jl","text":"CurrentModule = NPDemand","category":"page"},{"location":"","page":"NPDemand.jl","title":"NPDemand.jl","text":"Documentation for NPDemand.jl, a package for nonparametric demand estimation. This version of the package will be introduced formally and used by (in-progress) Brand, Compiani, and Smith (2023).  ","category":"page"},{"location":"#Package-Framework","page":"NPDemand.jl","title":"Package Framework","text":"","category":"section"},{"location":"","page":"NPDemand.jl","title":"NPDemand.jl","text":"This package is meant to make the estimation of price elasticities as easy, and as close to reg y x, r, as possible. There are three necessary steps: ","category":"page"},{"location":"","page":"NPDemand.jl","title":"NPDemand.jl","text":"Define a problem (an NPDProblem): at this stage, you specify your data, your model, and any econometric choices that are required up front. \nEstimate the problem: in the simplest case, this is a single call to the estimate! function. Otherwise, all that needs to be specified are details about how long to let the estimation run and other similar controls.\nProcess results: the problem has now stored the estimated parameters internally, and we've tried to provide functions to calculate the main objects of interest (price elasticities and demand functions) that do not require the user to know anything about what is happening under the hood. ","category":"page"},{"location":"","page":"NPDemand.jl","title":"NPDemand.jl","text":"This is similar to, and inspired by, the structure of the (much more extensive) PyBLP package in Python. Ideally, this structure makes the code modular enough that our package could be appended (either by the user or by us) with additional functions for more complicated processing and other results. ","category":"page"},{"location":"#Documentation-Contents","page":"NPDemand.jl","title":"Documentation Contents","text":"","category":"section"},{"location":"","page":"NPDemand.jl","title":"NPDemand.jl","text":"","category":"page"}]
}
